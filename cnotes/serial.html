<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (WinNT; U) [Netscape]">
   <title>Serial Communications in Win32</title>
<!--DocHeaderStart-->
</head>
<body bgcolor="#FFFFFF" link="#0000FF" TOPMARGIN="0" LEFTMARGIN="0">
<!--TOOLBAR_START-->
<br><!--TOOLBAR_END-->
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td WIDTH="10">&nbsp;</td>

<td>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 >
<tr>
<td></td>
</tr>
</table>
<!--DocHeaderEnd--><!-- This is a PANDA Generated HTML file. The source is a WinWord Document. --><a NAME="top"></a>
<h1>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Serial
Communications in Win32</font></font></h1>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Allen
Denver&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Microsoft
Windows Developer Support&nbsp;</font></font>
<p><!--DATE--><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>December
11, 1995&nbsp;</font></font>
<p><!--/DATE-->
<p><a href="./ser2416b.zip"><img SRC="icodownl.gif" ALT="Download" BORDER=0 height=20 width=16></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="./ser2416b.zip">
Download the MTTTY sample. (Afterwards, use PKUNZIP.EXE -d to recreate
directory structure.)</a></font></font>
<br>&nbsp;
<br>&nbsp;
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Contents</font></font></h3>
<b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#abstract">Abstract</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#intro">Introduction</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#readwrite">Reading
and Writing</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#status">Serial
Status</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#settings">Serial
Settings</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#conclusion">Conclusion</a></font></font></b>
<br><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><a href="#biblio">Bibliography</a></font></font></b>
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="abstract"></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Abstract</font></font></h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Serial
communications in Win32&reg; is significantly different from serial communications
in 16-bit Microsoft&reg; Windows&reg;. Those familiar with 16-bit serial
communications functions will have to relearn many parts of the system
to program serial communications properly. This article will help to accomplish
this. Those unfamiliar with serial communications will find this article
a helpful foundation for development efforts.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>This
article assumes the reader is familiar with the fundamentals of multiple
threading and synchronization in Win32. In addition, a basic familiarity
of the Win32 heap functions is useful to fully comprehend the memory management
methods utilized by the sample, MTTTY, included with this article. For
more information regarding these functions, consult the Win32 SDK documentation,
the Microsoft Win32 SDK Knowledge Base, or the Microsoft Developer Network
Library CD. Application programming interfaces (APIs) that control user
interface features of windows and dialog boxes, though not discussed here,
are useful to know in order to fully comprehend the sample provided with
this article. Readers unfamiliar with general Windows programming practices
should learn some of the fundamentals of general Windows programming before
taking on serial communications. In other words, get your feet wet before
diving in head first.&nbsp;</font></font>
<h2>
<a NAME="intro"></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Introduction</font></font></h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The focus
of this article is on APIs and methods that are compatible with Microsoft&reg;
Windows NT&reg; <i>and</i> Windows&reg; 95; therefore, APIs supported on
both platforms are the only ones discussed. Windows 95 supports the Win32&reg;
Telephony API (TAPI) and Windows NT 3. <i>x</i> does not; therefore, this
discussion will not include TAPI. TAPI does deserve mention, however, in
that it very nicely implements modem interfacing and call controlling.
A production application that works with modems and makes telephone calls
should implement these features using the TAPI interface. This will allow
seamless integration with the other TAPI-enabled applications that a user
may have. Furthermore, this article does not discuss some of the configuration
functions in Win32, such as <b>GetCommProperties</b>.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
article is broken into the following sections: Opening a port, reading
and writing (nonoverlapped and overlapped), serial status (events and errors),
and serial settings (DCB, flow control, and communications time-outs).</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
sample included with this article, MTTTY: Multithreaded TTY, implements
many of the features discussed here. It utilizes three threads in its implementation:
a user interface thread that does memory management, a writer thread that
controls all writing, and a reader/status thread that reads data and handles
status changes on the port. The sample employs a few different data heaps
for memory management. It also makes extensive use of synchronization methods
to facilitate communication between threads.</font></font>
<h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Opening
a Port</font></font></h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The <b>CreateFile</b>
function opens a communications port. There are two ways to call <b>CreateFile</b>
to open the communications port: overlapped and nonoverlapped. The following
is the proper way to open a communications resource for overlapped operation:</font></font>
<pre><font face="COURIER"><font size=-1>HANDLE hComm;

hComm = CreateFile( gszPort,&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GENERIC_READ | GENERIC_WRITE,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN_EXISTING,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_FLAG_OVERLAPPED,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

if (hComm == INVALID_HANDLE_VALUE)

&nbsp;&nbsp; // error opening port; abort</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Removal
of the FILE_FLAG_OVERLAPPED flag from the call to <b>CreateFile</b> specifies
nonoverlapped operation. The next section discusses overlapped and nonoverlapped
operations.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
Win32 SDK <i>Programmer's Reference</i> (Overviews, Window Management,
System Services) states that when opening a communications port, the call
to <b>CreateFile </b>has the following requirements:&nbsp;</font></font>
<ul>
<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><i>fdwShareMode
</i>must
be zero. Communications ports cannot be shared in the same manner that
files are shared. Applications utilizing TAPI can use the TAPI functions
to facilitate sharing resources between applications. For Win32 applications
not using TAPI, handle inheritance or duplication is necessary to share
the communications port. Handle duplication is beyond the scope of this
article; please refer to the Win32 SDK documentation for more information.&nbsp;</font></font></li>

<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><i>fdwCreate</i>
must specify the OPEN_EXISTING flag.</font></font></li>

<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>&nbsp;<i>hTemplateFile</i>
parameter must be NULL.&nbsp;</font></font></li>
</ul>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>One thing
to note about port names is that traditionally they have been COM1, COM2,
COM3, or COM4. The Win32 API does not provide any mechanism for determining
what ports exist on a system. Windows NT and Windows 95 keep track of installed
ports differently from one another, so any one method would not be portable
across all Win32 platforms. Some systems even have more ports than the
traditional maximum of four. Hardware vendors and serial-device-driver
writers are free to name the ports anything they like. For this reason,
it is best that users have the ability to specify the port name they want
to use. If a port does not exist, an error will occur (ERROR_FILE_NOT_FOUND)
after attempting to open the port, and the user should be notified that
the port isn't available.</font></font>
<h2>
<a NAME="readwrite"></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reading
and Writing</font></font></h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reading
from and writing to communications ports in Win32 is very similar to file
input/output (I/O) in Win32. In fact, the functions that accomplish file
I/O are the same functions used for serial I/O. I/O in Win32 can be done
either of two ways: overlapped or nonoverlapped. The Win32 SDK documentation
uses the terms <i>asynchronous</i> and <i>synchronous</i> to connote these
types of I/O operations. This article, however, uses the terms <i>overlapped</i>
and <i>nonoverlapped</i>.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><i>Nonoverlapped
I/O</i> is familiar to most developers because this is the traditional
form of I/O where an operation is requested and is assumed to be complete
when the function returns. In the case of <i>overlapped I/O</i>, the system
may return to the caller immediately even when an operation is not finished
and will signal the caller when the operation completes. The program may
use the time between the I/O request and its completion to perform some
"background" work.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reading
and writing in Win32 is significantly different from reading and writing
serial communications ports in 16-bit Windows. 16-bit Windows only has
the <b>ReadComm</b> and <b>WriteComm</b> functions. Win32 reading and writing
can involve many more functions and choices. These issues are discussed
below.</font></font>
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Nonoverlapped
I/O</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Nonoverlapped
I/O is very straightforward, though it has limitations. An operation takes
place while the calling thread is blocked. Once the operation is complete,
the function returns and the thread can continue its work. This type of
I/O is useful for multithreaded applications because while one thread is
blocked on an I/O operation, other threads can still perform work. It is
the responsibility of the application to serialize access to the port correctly.
If one thread is blocked waiting for its I/O operation to complete, all
other threads that subsequently call a communications API will be blocked
until the original operation completes. For instance, if one thread were
waiting for a <b>ReadFile </b>function to return, any other thread that
issued a <b>WriteFile</b> function would be blocked.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>One
of the many factors to consider when choosing between nonoverlapped and
overlapped operations is portability. Overlapped operation is not a good
choice because most operating systems do not support it. Most operating
systems support some form of multithreading, however, so multithreaded
nonoverlapped I/O may be the best choice for portability reasons.</font></font>
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Overlapped
I/O</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Overlapped
I/O is not as straightforward as nonoverlapped I/O, but allows more flexibility
and efficiency. A port open for overlapped operations allows multiple threads
to do I/O operations <i>at the same time</i> and perform other work while
the operations are pending. Furthermore, the behavior of overlapped operations
allows a single thread to issue many different requests and do work in
the background while the operations are pending.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>In
both single-threaded and multithreaded applications, some synchronization
must take place between issuing requests and processing the results. One
thread will have to be blocked until the result of an operation is available.
The advantage is that overlapped I/O allows a thread to do some work between
the time of the request and its completion. If no work <i>can </i>be done,
then the only case for overlapped I/O is that it allows for better user
responsiveness.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Overlapped
I/O is the type of operation that the MTTTY sample uses. It creates a thread
that is responsible for reading the port's data and reading the port's
status. It also performs periodic background work. The program creates
another thread exclusively for writing data out the port.</font></font>
<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
Applications sometimes abuse multithreading systems by creating too many
threads. Though utilizing multiple threads can resolve many difficult problems,
creating excessive threads is not the most efficient use of them in an
application. Threads are less a strain on the system than processes but
still require system resources such as CPU time and memory. An application
that creates excessive threads may adversely affect the performance of
the entire system. A better use of threads is to create a different request
queue for each type of job and to have a worker thread issue an I/O request
for each entry in the request queue. This method is used by the MTTTY sample
provided with this article.</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>An overlapped
I/O operation has two parts: the creation of the operation and the detection
of its completion. Creating the operation entails setting up an <b>OVERLAPPED</b>
structure, creating a manual-reset event for synchronization, and calling
the appropriate function (<b>ReadFile</b> or <b>WriteFile</b>). The I/O
operation may or may not be completed immediately. It is an error for an
application to assume that a request for an overlapped operation always
yields an overlapped operation. If an operation is completed immediately,
an application needs to be ready to continue processing normally. The second
part of an overlapped operation is to detect its completion. Detecting
completion of the operation involves waiting for the event handle, checking
the overlapped result, and then handling the data. The reason that there
is more work involved with an overlapped operation is that there are more
points of failure. If a nonoverlapped operation fails, the function just
returns an error-return result. If an overlapped operation fails, it can
fail in the creation of the operation or while the operation is pending.
You may also have a time-out of the operation or a time-out waiting for
the signal that the operation is complete.</font></font>
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reading</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The <b>ReadFile</b>
function issues a read operation. <b>ReadFileEx</b> also issues a read
operation, but since it is not available on Windows 95, it is not discussed
in this article. Here is a code snippet that details how to issue a read
request. Notice that the function calls a function to process the data
if the <b>ReadFile</b> returns TRUE. This is the same function called if
the operation becomes overlapped. Note the fWaitingOnRead flag that is
defined by the code; it indicates whether or not a read operation is overlapped.
It is used to prevent the creation of a new read operation if one is outstanding.</font></font>
<pre><font face="COURIER"><font size=-1>DWORD dwRead;

BOOL fWaitingOnRead = FALSE;

OVERLAPPED osReader = {0};



// Create the overlapped event. Must be closed before exiting

// to avoid a handle leak.

osReader.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);



if (osReader.hEvent == NULL)

&nbsp;&nbsp; // Error creating overlapped event; abort.



if (!fWaitingOnRead) {

&nbsp;&nbsp; // Issue read operation.

&nbsp;&nbsp; if (!ReadFile(hComm, lpBuf, READ_BUF_SIZE, &amp;dwRead, &amp;osReader)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetLastError() != ERROR_IO_PENDING)&nbsp;&nbsp;&nbsp;&nbsp; // read not delayed?

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in communications; report it.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fWaitingOnRead = TRUE;

&nbsp;&nbsp; }

&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read completed immediately

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleASuccessfulRead(lpBuf, dwRead);

&nbsp;&nbsp;&nbsp; }

}</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The second
part of the overlapped operation is the detection of its completion. The
event handle in the <b>OVERLAPPED</b> structure is passed to the <b>WaitForSingleObject</b>
function, which will wait until the object is signaled. Once the event
is signaled the operation is complete. This does not mean that it was completed
successfully, just that it was completed. The <b>GetOverlappedResult</b>
function reports the result of the operation. If an error occurred, the
<b>GetOverlappedResult</b>
returns FALSE, and <b>GetLastError</b> returns the error code. If the operation
was completed successfully, <b>GetOverlappedResult</b> will return TRUE.</font></font>
<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>NoteGetOverlappedResult</b>
can detect completion of the operation, as well as return the operation's
failure status. <b>GetOverlappedResult</b> returns FALSE and <b>GetLastError</b>
returns ERROR_IO_INCOMPLETE when the operation is not completed. In addition,
<b>GetOverlappedResult</b>
can be made to block until the operation completes. This effectively turns
the overlapped operation into a nonoverlapped operation and is accomplished
by passing TRUE as the <i>bWait</i> parameter.</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here is
a code snippet that shows one way to detect the completion of an overlapped
read operation. Note that the code calls the same function to process the
data that was called when the operation completed immediately. Also note
the use of the fWaitingOnRead flag. Here it controls entry into the detection
code since it should be called only when an operation is outstanding.</font></font>
<pre><font face="COURIER"><font size=-1>#define READ_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 500&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // milliseconds



DWORD dwRes;



if (fWaitingOnRead) {

&nbsp;&nbsp; dwRes = WaitForSingleObject(osReader.hEvent, READ_TIMEOUT);

&nbsp;&nbsp; switch(dwRes)

&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Read completed.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_OBJECT_0:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!GetOverlappedResult(hComm, &amp;osReader, &amp;dwRead, FALSE))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in communications; report it.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Read completed successfully.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleASuccessfulRead(lpBuf, dwRead);



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Reset flag so that another opertion can be issued.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fWaitingOnRead = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_TIMEOUT:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Operation isn't complete yet. fWaitingOnRead flag isn't

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // changed since I'll loop back around, and I don't want

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to issue another read until the first one finishes.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is a good time to do some background work.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in the WaitForSingleObject; abort.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This indicates a problem with the OVERLAPPED structure's

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp; }

}</font></font>

</pre>

<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Writing</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Transmitting
data out the communications port is very similar to reading in that it
utilizes a lot of the same APIs. The code snippet below demonstrates how
to issue and wait for a write operation to be completed.</font></font>
<pre><font face="COURIER"><font size=-1>BOOL WriteABuffer(char * lpBuf, DWORD dwToWrite)

{

&nbsp;&nbsp; OVERLAPPED osWrite = {0};

&nbsp;&nbsp; DWORD dwWritten;

&nbsp;&nbsp; DWORD dwRes;

&nbsp;&nbsp; BOOL fRes;



&nbsp;&nbsp; // Create this write operation's OVERLAPPED structure's hEvent.

&nbsp;&nbsp; osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

&nbsp;&nbsp; if (osWrite.hEvent == NULL)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error creating overlapped event handle

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;



&nbsp;&nbsp; // Issue write.

&nbsp;&nbsp; if (!WriteFile(hComm, lpBuf, dwToWrite, &amp;dwWritten, &amp;osWrite)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetLastError() != ERROR_IO_PENDING) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile failed, but isn't delayed. Report error and abort.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write is pending.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRes = WaitForSingleObject(osWrite.hEvent, INFINITE);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(dwRes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OVERLAPPED structure's event has been signalled.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_OBJECT_0:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!GetOverlappedResult(hComm, &amp;osWrite, &amp;dwWritten, FALSE))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write operation completed successfully.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error has occurred in WaitForSingleObject.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This usually indicates a problem with the

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OVERLAPPED structure's event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp; }

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile completed immediately.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;



&nbsp;&nbsp; CloseHandle(osWrite.hEvent);

&nbsp;&nbsp; return fRes;

}</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Notice
that the code above uses the <b>WaitForSingleObject </b>function with a
time-out value of INFINITE. This causes the <b>WaitForSingleObject</b>
function to wait forever until the operation is completed; this may make
the thread or program appear to be "hung" when, in fact, the write operation
is simply taking a long time to complete or flow control has blocked the
transmission. Status checking, discussed later, can detect this condition,
but doesn't cause the <b>WaitForSingleObject</b> to return. Three things
can alleviate this condition:&nbsp;</font></font>
<ul>
<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Place
the code in a separate thread. This allows other threads to execute any
functions they desire while our writer thread waits for the write to be
completed. This is what the MTTTY sample does.&nbsp;</font></font></li>

<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Utilize
COMMTIMEOUTS to cause the write to be completed after a time-out period
has passed. This is discussed more fully in the Communications Time-outs
section later. This is also what the MTTTY sample allows.&nbsp;</font></font></li>

<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Change
the <b>WaitForSingleObject</b> call to include a real time-out value. This
causes more problems because, if the program issues another operation while
an older operation is still pending, new <b>OVERLAPPED</b> structures and
overlapped events need to be allocated. This type of recordkeeping is difficult,
particularly when compared to utilizing a "job queue" design for the operations.
The "job queue" method is used in the MTTTY sample.&nbsp;</font></font></li>
</ul>

<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
The time-out values in synchronization functions are not communications
time-outs. Synchronization time-outs cause <b>WaitForSingleObject</b> or
<b>WaitForMultipleObjects</b>
to return WAIT_TIMEOUT. This is not the same as a read or write operation
timing out. Communications time-outs are described later in this article.</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Because
the <b>WaitForSingleObject</b> function in the above code snippet uses
an INFINITE time-out, it is equivalent to using <b>GetOverlappedResult</b>
with TRUE for the <i>fWait</i> parameter. Here is equivalent code in a
much simplified form:</font></font>
<pre><font face="COURIER"><font size=-1>BOOL WriteABuffer(char * lpBuf, DWORD dwToWrite)

{

&nbsp;&nbsp; OVERLAPPED osWrite = {0};

&nbsp;&nbsp; DWORD dwWritten;

&nbsp;&nbsp; BOOL fRes;



&nbsp;&nbsp; // Create this writes OVERLAPPED structure hEvent.

&nbsp;&nbsp; osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

&nbsp;&nbsp; if (osWrite.hEvent == NULL)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error creating overlapped event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;



&nbsp;&nbsp; // Issue write.

&nbsp;&nbsp; if (!WriteFile(hComm, lpBuf, dwToWrite, &amp;dwWritten, &amp;osWrite)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetLastError() != ERROR_IO_PENDING) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile failed, but it isn't delayed. Report error and abort.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write is pending.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!GetOverlappedResult(hComm, &amp;osWrite, &amp;dwWritten, TRUE))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write operation completed successfully.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp; }

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile completed immediately.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;



&nbsp;&nbsp; CloseHandle(osWrite.hEvent);

&nbsp;&nbsp; return fRes;

}</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>GetOverlappedResult</b>
is not always the best way to wait for an overlapped operation to be completed.
For example, if an application needs to wait on another event handle, the
first code snippet serves as a better model than the second. The call to
<b>WaitForSingleObject</b>
is easy to change to <b>WaitForMultipleObjects</b> to include the additional
handles on which to wait. This is what the MTTTY sample application does.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A common
mistake in overlapped I/O is to reuse an <b>OVERLAPPED</b> structure before
the previous overlapped operation is completed. If a new overlapped operation
is issued before a previous operation is completed, a new <b>OVERLAPPED</b>
structure must be allocated for it. A new manual-reset event for the <b>hEvent</b>
member of the <b>OVERLAPPED</b> structure must also be created. Once an
overlapped operation is complete, the <b>OVERLAPPED</b> structure and its
event are free for reuse.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
only member of the <b>OVERLAPPED</b> structure that needs modifying for
serial communications is the <b>hEvent</b> member. The other members of
the <b>OVERLAPPED</b> structure should be initialized to zero and left
alone. Modifying the other members of the <b>OVERLAPPED</b> structure is
not necessary for serial communications devices. The documentation for
<b>ReadFile</b>
and <b>WriteFile</b> state that the <b>Offset</b> and <b>OffsetHigh</b>
members of the <b>OVERLAPPED</b> structure must be updated by the application,
or results are unpredictable. This guideline should be applied to <b>OVERLAPPED</b>
structures used for other types of resources, such as files.&nbsp;</font></font>
<h2>
<a NAME="status"></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Serial
Status</font></font></h2>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>There
are two methods to retrieve the status of a communications port. The first
is to set an event mask that causes notification of the application when
the desired events occur. The <b>SetCommMask</b> function sets this event
mask, and the <b>WaitCommEvent</b> function waits for the desired events
to occur. These functions are similar to the 16-bit functions <b>SetCommEventMask</b>
and <b>EnableCommNotification</b>, except that the Win32 functions do not
post WM_COMMNOTIFY messages. In fact, the WM_COMMNOTIFY message is not
even part of the Win32 API. The second method for retrieving the status
of the communications port is to periodically call a few different status
functions. Polling is, of course, neither efficient nor recommended.&nbsp;</font></font>
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Communications
Events</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Communications
events can occur at any time in the course of using a communications port.
The two steps involved in receiving notification of communications events
are as follows:&nbsp;</font></font>
<ul>
<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>SetCommMask</b>
sets the desired events that cause a notification.&nbsp;</font></font></li>

<li>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>WaitCommEvent</b>
issues a status check. The status check can be an overlapped or nonoverlapped
operation, just as the read and write operations can be.&nbsp;</font></font></li>
</ul>

<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
The word <i>event </i>in this context refers to communications events only.
It does not refer to an event object used for synchronization.</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here is
an example of the <b>SetCommMask</b> function:</font></font>
<pre><font face="COURIER"><font size=-1>DWORD dwStoredFlags;



dwStoredFlags = EV_BREAK | EV_CTS&nbsp;&nbsp; | EV_DSR | EV_ERR | EV_RING |\

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY ;

if (!SetCommMask(hComm, dwStoredFlags))

&nbsp;&nbsp; // error setting communications mask</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A description
of each type of event is in Table 1.&nbsp;</font></font>
<h3>
<b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Table
1. Communications Event Flags</font></font></b></h3>

<table BORDER CELLSPACING=0 CELLPADDING=5 WIDTH="87%" >
<tr VALIGN=TOP BGCOLOR="#DDDDDD">
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Event
Flag</font></font></b></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Description</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_BREAK</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A
break was detected on input.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_CTS</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
CTS (clear-to-send) signal changed state. To get the actual state of the
CTS line, <b>GetCommModemStatus</b> should be called.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_DSR</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
DSR (data-set-ready) signal changed state. To get the actual state of the
DSR line, <b>GetCommModemStatus</b> should be called.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_ERR</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A
line-status error occurred. Line-status errors are CE_FRAME, CE_OVERRUN,
and CE_RXPARITY. To find the cause of the error, <b>ClearCommError</b>
should be called.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_RING</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A
ring indicator was detected.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_RLSD</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
RLSD (receive-line-signal-detect) signal changed state. To get the actual
state of the RLSD line, <b>GetCommModemStatus</b> should be called. Note
that this is commonly referred to as the CD (carrier detect) line.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_RXCHAR</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>A
new character was received and placed in the input buffer. See Caveat section
below for a discussion of this flag.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_RXFLAG</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
event character was received and placed in the input buffer. The event
character is specified in the <b>EvtChar</b> member of the <b>DCB</b> structure
discussed later. The Caveat section below also applies to this flag.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EV_TXEMPTY</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
last character in the output buffer was sent to the serial port device.
If a hardware buffer is used, this flag only indicates that all data has
been sent to the hardware. There is no way to detect when the hardware
buffer is empty without talking directly to the hardware with a device
driver.&nbsp;</font></font></td>
</tr>
</table>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>After
specifying the event mask, the <b>WaitCommEvent</b> function detects the
occurrence of the events. If the port is open for nonoverlapped operation,
then the <b>WaitCommEvent</b> function does not contain an <b>OVERLAPPED</b>
structure. The function blocks the calling thread until the occurrence
of one of the events. If an event never occurs, the thread may block indefinitely.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here
is a code snippet that shows how to wait for an EV_RING event when the
port is open for nonoverlapped operation:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; DWORD dwCommEvent;



&nbsp;&nbsp; if (!SetCommMask(hComm, EV_RING))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error setting communications mask

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;



&nbsp;&nbsp; if (!WaitCommEvent(hComm, &amp;dwCommEvent, NULL))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error occured waiting for the event.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Event has occurred.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</font></font>

</pre>

<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
The Microsoft Win32 SDK Knowledge Base documents a problem with Windows
95 and the EV_RING flag. The above code never returns in Windows 95 because
the EV_RING event is not detected by the system; Windows NT properly reports
the EV_RING event. Please see the Win32 SDK Knowledge Base for more information
on this bug.</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>As noted,
the code above can be blocked forever if an event never occurs. A better
solution would be to open the port for overlapped operation and wait for
a status event in the following manner:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; #define STATUS_CHECK_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 500&nbsp;&nbsp; // Milliseconds



&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRes;

&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwCommEvent;

&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwStoredFlags;

&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fWaitingOnStat = FALSE;

&nbsp;&nbsp; OVERLAPPED osStatus = {0};



&nbsp;&nbsp; dwStoredFlags = EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING |\

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY ;

&nbsp;&nbsp; if (!SetCommMask(comHandle, dwStoredFlags))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error setting communications mask; abort

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;



&nbsp;&nbsp; osStatus.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

&nbsp;&nbsp; if (osStatus.hEvent == NULL)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error creating event; abort

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;



&nbsp;&nbsp; for ( ; ; ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Issue a status event check if one hasn't been issued already.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!fWaitingOnStat) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!WaitCommEvent(hComm, &amp;dwCommEvent, &amp;osStatus)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetLastError() == ERROR_IO_PENDING)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bWaitingOnStatusHandle = TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error in WaitCommEvent; abort

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WaitCommEvent returned immediately.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Deal with status event as appropriate.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportStatusEvent(dwCommEvent);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check on overlapped operation.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fWaitingOnStat) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Wait a little while for an event to occur.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRes = WaitForSingleObject(osStatus.hEvent, STATUS_CHECK_TIMEOUT);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(dwRes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Event occurred.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_OBJECT_0:&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!GetOverlappedResult(hComm, &amp;osStatus, &amp;dwOvRes, FALSE))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error occurred in the overlapped operation;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call GetLastError to find out what it was

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and abort if it is fatal.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Status event is stored in the event flag

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // specified in the original WaitCommEvent call.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Deal with the status event as appropriate.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportStatusEvent(dwCommEvent);



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set fWaitingOnStat flag to indicate that a new

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WaitCommEvent is to be issued.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fWaitingOnStat = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_TIMEOUT:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Operation isn't complete yet. fWaitingOnStatusHandle flag&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // isn't changed since I'll loop back around and I don't want

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to issue another WaitCommEvent until the first one finishes.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is a good time to do some background work.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoBackgroundWork();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in the WaitForSingleObject; abort

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This indicates a problem with the OVERLAPPED structure's

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(osStatus.hEvent);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp; }



&nbsp;&nbsp; CloseHandle(osStatus.hEvent);</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The code
above very closely resembles the code for overlapped reading. In fact,
the MTTTY sample implements its reading and status checking in the same
thread using <b>WaitForMultipleObjects</b> to wait for either the read
event or the status event to become signaled.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>There
are two interesting side effects of <b>SetCommMask</b> and <b>WaitCommEvent</b>.
First, if the communications port is open for nonoverlapped operation,
<b>WaitCommEvent</b>
will be blocked until an event occurs. If another thread calls <b>SetCommMask</b>
to set a new event mask, that thread will be blocked on the call to <b>SetCommMask</b>.
The reason is that the original call to <b>WaitCommEvent</b> in the first
thread is still executing. The call to <b>SetCommMask</b> blocks the thread
until the <b>WaitCommEvent</b> function returns in the first thread. This
side effect is universal for ports open for nonoverlapped I/O. If a thread
is blocked on <i>any</i> communications function and another thread calls
a communications function, the second thread is blocked until the communications
function returns in the first thread. The second interesting note about
these functions is their use on a port open for overlapped operation. If
<b>SetCommMask</b>
sets a new event mask, any pending <b>WaitCommEvent</b> will complete successfully,
and the event mask produced by the operation is NULL.</font></font>
<h4>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Caveat</font></font></h4>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Using
the EV_RXCHAR flag will notify the thread that a byte arrived at the port.
This event, used in combination with the <b>ReadFile</b> function, enables
a program to read data only <i>after</i> it is in the receive buffer, as
opposed to issuing a read that <i>waits</i> for the data to arrive. This
is particularly useful when a port is open for nonoverlapped operation
because the program does not need to poll for incoming data; the program
is notified of the incoming data by the occurrence of the EV_RXCHAR event.
Initial attempts to code this solution often produce the following pseudocode,
including one oversight covered in a moment:</font></font>
<pre><font face="COURIER"><font size=-1>DWORD dwCommEvent;

DWORD dwRead;

char&nbsp; chRead;



if (!SetCommMask(hComm, EV_RXCHAR))

&nbsp;&nbsp; // Error setting communications event mask.



for ( ; ; ) {

&nbsp;&nbsp; if (WaitCommEvent(hComm, &amp;dwCommEvent, NULL)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ReadFile(hComm, &amp;chRead, 1, &amp;dwRead, NULL))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A byte has been read; process it.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error occurred in the ReadFile call.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp; }

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in WaitCommEvent.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

}</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The above
code waits for an EV_RXCHAR event to occur. When this happens, the code
calls <b>ReadFile</b> to read the one byte received. The loop starts again,
and the code waits for another EV_RXCHAR event. This code works fine when
one or two bytes arrive in quick succession. The byte reception causes
the EV_RXCHAR event to occur. The code reads the byte. If no other byte
arrives before the code calls <b>WaitCommEvent</b> again, then all is fine;
the next byte to arrive will cause the <b>WaitCommEvent</b> function to
indicate the occurrence of the EV_RXCHAR event. If another single byte
arrives before the code has a chance to reach the <b>WaitCommEvent</b>
function, then all is fine, too. The first byte is read as before; the
second byte's arrival causes the EV_RXCHAR flag to be set internally. When
the code returns to the <b>WaitCommEvent</b> function, it indicates the
occurrence of the EV_RXCHAR event and the second byte is read from the
port in the <b>ReadFile</b> call.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
problem with the above code occurs when three or more bytes arrive in quick
succession. The first byte causes the EV_RXCHAR event to occur. The second
byte causes the EV_RXCHAR flag to be set internally. The next time the
code calls <b>WaitCommEvent</b>, it indicates the EV_RXCHAR event. Now,
a third byte arrives at the communications port. This third byte causes
the system to attempt to set the EV_RXCHAR flag internally. Since this
has already occurred when the second byte arrived, the arrival of the third
byte goes unnoticed. The code eventually will read the first byte without
a problem. After this, the code will call <b>WaitCommEvent</b>, and it
indicates the occurrence of the EV_RXCHAR event (from the arrival of the
second byte). The second byte is read, and the code returns to the <b>WaitCommEvent</b>
function. The third byte waits in the system's internal receive buffer.
The code and the system are now out of sync. When a fourth byte finally
arrives, the EV_RXCHAR event occurs, and the code reads a single byte.
It reads the third byte. This will continue indefinitely.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
solution to this problem seems as easy as increasing the number of bytes
requested in the read operation. Instead of requesting a single byte, the
code could request two, ten, or some other number of bytes. The problem
with this idea is that it still fails when two or more extra bytes above
the size of the read request arrive at the port in quick succession. So,
if two bytes are read, then four bytes arriving in quick succession would
cause the problem. Ten bytes requested would still fail if twelve bytes
arrived in quick succession.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
real solution to this problem is to read from the port until no bytes are
remaining. The following pseudocode solves the problem by reading in a
loop until zero characters are read. Another possible method would be to
call <b>ClearCommError</b> to determine the number of bytes in the buffer
and read them all in one read operation. This requires more sophisticated
buffer management, but reduces the number of reads when a lot of data arrives
at once.</font></font>
<pre><font face="COURIER"><font size=-1>DWORD dwCommEvent;

DWORD dwRead;

char&nbsp; chRead;



if (!SetCommMask(hComm, EV_RXCHAR))

&nbsp;&nbsp; // Error setting communications event mask



for ( ; ; ) {

&nbsp;&nbsp; if (WaitCommEvent(hComm, &amp;dwCommEvent, NULL)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ReadFile(hComm, &amp;chRead, 1, &amp;dwRead, NULL))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A byte has been read; process it.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error occurred in the ReadFile call.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while (dwRead);

&nbsp;&nbsp; }

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in WaitCommEvent

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

}</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The above
code does not work correctly without setting the proper time-outs. Communications
time-outs, discussed later, affect the behavior of the <b>ReadFile</b>
operation in order to cause it to return without waiting for bytes to arrive.
Discussion of this topic occurs later in the "Communications Time-outs"
section of this article.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
above caveat regarding EV_RXCHAR also applies to EV_RXFLAG. If flag characters
arrive in quick succession, EV_RXFLAG events may not occur for all of them.
Once again, the best solution is to read all bytes until none remain.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
above caveat also applies to other events not related to character reception.
If other events occur in quick succession some of the notifications will
be lost. For instance, if the CTS line voltage starts high, then goes low,
high, and low again, an EV_CTS event occurs. There is no guarantee of how
many EV_CTS events will actually be detected with <b>WaitCommEvent</b>
if the changes in the CTS line happen quickly. For this reason, <b>WaitCommEvent</b>
cannot be used to keep track of the state of the line. Line status is covered
in the "Modem Status" section later in this article.</font></font>
<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Error
Handling and Communications Status</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>One of
the communications event flags specified in the call to <b>SetCommMask</b>
is possibly EV_ERR. The occurrence of the EV_ERR event indicates that an
error condition exists in the communications port. Other errors can occur
in the port that do not cause the EV_ERR event to occur. In either case,
errors associated with the communications port cause all I/O operations
to suspend until removal of the error condition. <b>ClearCommError</b>
is the function to call to detect errors and clear the error condition.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>ClearCommError</b>
also provides communications status indicating why transmission has stopped;
it also indicates the number of bytes waiting in the transmit and receive
buffers. The reason why transmission may stop is because of errors or due
to flow control. The discussion of flow control occurs later in this article.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here
is some code that demonstrates how to call <b>ClearCommError</b>:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp;&nbsp; COMSTAT comStat;

&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; dwErrors;

&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; fOOP, fOVERRUN, fPTO, fRXOVER, fRXPARITY, fTXFULL;

&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; fBREAK, fDNS, fFRAME, fIOE, fMODE;



&nbsp;&nbsp;&nbsp; // Get and clear current errors on the port.

&nbsp;&nbsp;&nbsp; if (!ClearCommError(hComm, &amp;dwErrors, &amp;comStat))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Report error in ClearCommError.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;



&nbsp;&nbsp;&nbsp; // Get error flags.

&nbsp;&nbsp;&nbsp; fDNS = dwErrors &amp; CE_DNS;

&nbsp;&nbsp;&nbsp; fIOE = dwErrors &amp; CE_IOE;

&nbsp;&nbsp;&nbsp; fOOP = dwErrors &amp; CE_OOP;

&nbsp;&nbsp;&nbsp; fPTO = dwErrors &amp; CE_PTO;

&nbsp;&nbsp;&nbsp; fMODE = dwErrors &amp; CE_MODE;

&nbsp;&nbsp;&nbsp; fBREAK = dwErrors &amp; CE_BREAK;

&nbsp;&nbsp;&nbsp; fFRAME = dwErrors &amp; CE_FRAME;

&nbsp;&nbsp;&nbsp; fRXOVER = dwErrors &amp; CE_RXOVER;

&nbsp;&nbsp;&nbsp; fTXFULL = dwErrors &amp; CE_TXFULL;

&nbsp;&nbsp;&nbsp; fOVERRUN = dwErrors &amp; CE_OVERRUN;

&nbsp;&nbsp;&nbsp; fRXPARITY = dwErrors &amp; CE_RXPARITY;



&nbsp;&nbsp;&nbsp; // COMSTAT structure contains information regarding

&nbsp;&nbsp;&nbsp; // communications status.

&nbsp;&nbsp;&nbsp; if (comStat.fCtsHold)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tx waiting for CTS signal



&nbsp;&nbsp;&nbsp; if (comStat.fDsrHold)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tx waiting for DSR signal



&nbsp;&nbsp;&nbsp; if (comStat.fRlsdHold)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tx waiting for RLSD signal



&nbsp;&nbsp;&nbsp; if (comStat.fXoffHold)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tx waiting, XOFF char rec'd



&nbsp;&nbsp;&nbsp; if (comStat.fXoffSent)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tx waiting, XOFF char sent

&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; if (comStat.fEof)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // EOF character received

&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; if (comStat.fTxim)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Character waiting for Tx; char queued with TransmitCommChar



&nbsp;&nbsp;&nbsp; if (comStat.cbInQue)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comStat.cbInQue bytes have been received, but not read



&nbsp;&nbsp;&nbsp; if (comStat.cbOutQue)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comStat.cbOutQue bytes are awaiting transfer</font></font>

</pre>

<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Modem
Status (a.k.a. Line Status)</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The call
to <b>SetCommMask</b> may include the flags EV_CTS, EV_DSR, EV_RING, and
EV_RLSD. These flags indicate changes in the voltage on the lines of the
serial port. There is no indication of the actual status of these lines,
just that a change occurred. The <b>GetCommModemStatus</b> function retrieves
the actual state of these status lines by returning a bit mask indicating
a 0 for low or no voltage and 1 for high voltage for each of the lines.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Please
note that the term "RLSD" (Receive Line Signal Detect) is commonly referred
to as the CD (Carrier Detect) line.</font></font>
<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
The EV_RING flag does not work in Windows 95 as mentioned earlier. The
<b>GetCommModemStatus</b>
function, however, does detect the state of the RING line.&nbsp;</font></font></blockquote>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Changes
in these lines may also cause a flow-control event. The <b>ClearCommError</b>
function reports whether transmission is suspended because of flow control.
If necessary, a thread may call <b>ClearCommError</b> to detect if the
event is the cause of a flow-control action. Flow control is covered in
the Flow control section later in this article.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here
is some code that demonstrates how to call <b>GetCommModemStatus</b>:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; DWORD dwModemStatus;

&nbsp;&nbsp; BOOL&nbsp; fCTS, fDSR, fRING, fRLSD;



&nbsp;&nbsp; if (!GetCommModemStatus(hComm, &amp;dwModemStatus))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in GetCommModemStatus;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;



&nbsp;&nbsp; fCTS = MS_CTS_ON &amp; dwModemStatus;

&nbsp;&nbsp; fDSR = MS_DSR_ON &amp; dwModemStatus;

&nbsp;&nbsp; fRING = MS_RING_ON &amp; dwModemStatus;

&nbsp;&nbsp; fRLSD = MS_RLSD_ON &amp; dwModemStatus;



&nbsp;&nbsp; // Do something with the flags.</font></font>

</pre>

<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Extended
Functions</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The driver
will automatically change the state of control lines as necessary. Generally
speaking, changing status lines is under the control of a driver. If a
device uses communications port control lines in a manner different from
RS-232 standards, the standard serial communications driver will not work
to control the device. If the standard serial communications driver will
not control the device, a custom device driver is necessary.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>There
are occasions when standard control lines <i>are</i> under the control
of the application instead of the serial communications driver. For instance,
an application may wish to implement its own flow control. The application
would be responsible for changing the status of the RTS and DTR lines.
<b>EscapeCommFunction</b>
directs a communications driver to perform such extended operations. <b>EscapeCommFunction</b>
can make the driver perform some other function, such as setting or clearing
a BREAK condition. For more information on this function, consult the Win32
SDK documentation, the Microsoft Win32 SDK Knowledge Base, or the MSDN
Library.</font></font>
<h2>
<a NAME="settings"></a><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Serial
Settings</font></font></h2>

<h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DCB Settings</font></font></h3>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The most
crucial aspect of programming serial communications applications is the
settings in the Device-Control Block (DCB) structure. The most common errors
in serial communications programming occur in initializing the DCB structure
improperly. When the serial communications functions do not behave as expected,
a close examination of the DCB structure usually reveals the problem.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>There
are three ways to initialize a DCB structure. The first method is to use
the function <b>GetCommState</b>. This function returns the current DCB
in use for the communications port. The following code shows how to use
the <b>GetCommState</b> function:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; DCB dcb = {0};



&nbsp;&nbsp; if (!GetCommState(hComm, &amp;dcb))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error getting current DCB settings

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DCB is ready for use.</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The second
method to initialize a DCB is to use a function called <b>BuildCommDCB</b>.
This function fills in the baud rate, parity type, number of stop bits,
and number of data bits members of the DCB. The function also sets the
flow-control members to default values. Consult the documentation of the
<b>BuildCommDCB</b>
function for details on which default values it uses for flow-control members.
Other members of the DCB are unaffected by this function. It is the program's
duty to make sure the other members of the DCB do not cause errors. The
simplest thing to do in this regard is to initialize the DCB structure
with zeros and then set the size member to the size, in bytes, of the structure.
If the zero initialization of the DCB structure does not occur, then there
may be nonzero values in the reserved members; this produces an error when
trying to use the DCB later. The following function shows how to properly
use this method:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; DCB dcb;



&nbsp;&nbsp; FillMemory(&amp;dcb, sizeof(dcb), 0);

&nbsp;&nbsp; dcb.DCBlength = sizeof(dcb);

&nbsp;&nbsp; if (!BuildCommDCB("9600,n,8,1", &amp;dcb)) {&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Couldn't build the DCB. Usually a problem

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with the communications specification string.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

&nbsp;&nbsp; }

&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DCB is ready for use.</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The third
method to initialize a DCB structure is to do it manually. The program
allocates the DCB structure and sets each member with any value desired.
This method does not deal well with changes to the DCB in future implementations
of Win32 and is not recommended.</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>An
application usually needs to set some of the DCB members differently than
the defaults or may need to modify settings in the middle of execution.
Once proper initialization of the DCB occurs, modification of individual
members is possible. The changes to the DCB structure do not have any effect
on the behavior of the port until execution of the <b>SetCommState</b>
function. Here is a section of code that retrieves the current DCB, changes
the baud rate and then attempts to set the configuration:</font></font>
<pre><font face="COURIER"><font size=-1>&nbsp;&nbsp; DCB dcb;



&nbsp;&nbsp; FillMemory(&amp;dcb, sizeof(dcb), 0);

&nbsp;&nbsp; if (!GetCommState(hComm, &amp;dcb))&nbsp;&nbsp;&nbsp;&nbsp; // get current DCB

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in GetCommState

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;



&nbsp;&nbsp; // Update DCB rate.

&nbsp;&nbsp; dcb.BaudRate = CBR_9600 ;



&nbsp;&nbsp; // Set new state.

&nbsp;&nbsp; if (!SetCommState(hComm, &amp;dcb))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error in SetCommState. Possibly a problem with the communications&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // port handle or a problem with the DCB structure itself.</font></font>

</pre>
<font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Here is
an explanation of each of the members of the DCB and how they affect other
parts of the serial communications functions.&nbsp;</font></font>
<blockquote><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1><b>Note</b>
Most of this information is from the Win32 Software Development Kit (SDK)
documentation. Since documentation is the official word in what the members
actually are and what they mean, this table may not be completely accurate
if changes occur in the operating system.</font></font></blockquote>

<h3>
<b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Table
2. The DCB Structure Members</font></font></b></h3>

<table BORDER CELLSPACING=0 CELLPADDING=5 WIDTH="95%" >
<caption><!-- End of second nested table -->
<br><!-- End of third nested table -->
<br><!-- End fourth nested table --></caption>

<tr VALIGN=TOP BGCOLOR="#DDDDDD">
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Member</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Description</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DCBlength</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Size,
in bytes, of the structure. Should be set before calling <b>SetCommState</b>
to update the settings.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>BaudRate</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the baud rate at which the communications device operates. This member
can be an actual baud rate value, or a baud rate index.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fBinary</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether binary mode is enabled. The Win32 API does not support non-binary
mode transfers, so this member should be TRUE. Trying to use FALSE will
not work.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fParity</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether parity checking is enabled. If this member is TRUE, parity checking
is performed and parity errors are reported. This should not be confused
with the <b>Parity</b> member, which controls the type of parity used in
communications.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fOutxCtsFlow</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether the CTS (clear-to-send) signal is monitored for output flow control.
If this member is TRUE and CTS is low, output is suspended until CTS is
high again. The CTS signal is under control of the DCE (usually a modem),
the DTE (usually the PC) simply monitors the status of this signal, it
does not change it.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fOutxDsrFlow</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether the DSR (data-set-ready) signal is monitored for output flow control.
If this member is TRUE and DSR is low, output is suspended until DSR is
high again. Once again, this signal is under the control of the DCE; the
DTE only monitors this signal.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fDtrControl</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the DTR (data-terminal-ready) input flow control. This member can be one
of the following values:&nbsp;</font></font><!-- This is a nested table. -->
<table BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH="95%" >
<tr VALIGN=TOP>
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Value</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Meaning</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DTR_CONTROL_DISABLE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Lowers
the DTR line when the device is opened. The application can adjust the
state of the line with <b>EscapeCommFunction</b>.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DTR_CONTROL_ENABLE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Raises
the DTR line when the device is opened. The application can adjust the
state of the line with <b>EscapeCommFunction</b>.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DTR_CONTROL_HANDSHAKE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Enables
DTR flow-control handshaking. If this value is used, it is an error for
the application to adjust the line with <b>EscapeCommFunction</b>.&nbsp;</font></font></td>
</tr>
</table>
</td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fDsrSensitivity</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether the communications driver is sensitive to the state of the DSR
signal. If this member is TRUE, the driver ignores any bytes received,
unless the DSR modem input line is high.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fTXContinueOnXoff</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether transmission stops when the input buffer is full and the driver
has transmitted the XOFF character. If this member is TRUE, transmission
continues after the XOFF has been sent. If this member is FALSE, transmission
does not continue until the input buffer is within XonLim bytes of being
empty and the driver has transmitted the XON character.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fOutX</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether XON/XOFF flow control is used during transmission. If this member
is TRUE, transmission stops when the XOFF character is received and starts
again when the XON character is received.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fInX</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether XON/XOFF flow control is used during reception. If this member
is TRUE, the XOFF character is sent when the input buffer comes within
XoffLim bytes of being full, and the XON character is sent when the input
buffer comes within XonLim bytes of being empty.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fErrorChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether bytes received with parity errors are replaced with the character
specified by the <b>ErrorChar</b> member. If this member is TRUE and the
<b>fParity</b>
member is TRUE, replacement occurs.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fNull</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether null bytes are discarded. If this member is TRUE, null bytes are
discarded when received.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fRtsControl</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the RTS (request-to-send) input flow control. If this value is zero, the
default is RTS_CONTROL_HANDSHAKE. This member can be one of the following
values:&nbsp;</font></font><!-- Begin second nested table -->
<table BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH="85%" >
<tr VALIGN=TOP>
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Value</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Meaning</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>RTS_CONTROL_DISABLE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Lowers
the RTS line when the device is opened. The application can use <b>EscapeCommFunction</b>
to change the state of the line.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>RTS_CONTROL_ENABLE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Raises
the RTS line when the device is opened. The application can use <b>EscapeCommFunction</b>
to change the state of the line.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>RTS_CONTROL_HANDSHAKE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Enables
RTS flow-control handshaking. The driver raises the RTS line, enabling
the DCE to send, when the input buffer has enough room to receive data.
The driver lowers the RTS line, preventing the DCE to send, when the input
buffer does not have enough room to receive data. If this value is used,
it is an error for the application to adjust the line with <b>EscapeCommFunction</b>.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>RTS_CONTROL_TOGGLE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
that the RTS line will be high if bytes are available for transmission.
After all buffered bytes have been sent, the RTS line will be low. If this
value is set, it would be an error for an application to adjust the line
with <b>EscapeCommFunction</b>. This value is ignored in Windows 95; it
causes the driver to act as if RTS_CONTROL_ENABLE were specified.&nbsp;</font></font></td>
</tr>
</table>
</td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fAbortOnError</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
whether read and write operations are terminated if an error occurs. If
this member is TRUE, the driver terminates all read and write operations
with an error status (ERROR_IO_ABORTED) if an error occurs. The driver
will not accept any further communications operations until the application
has acknowledged the error by calling the <b>ClearCommError</b> function.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>fDummy2</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reserved;
do not use.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>wReserved</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Not
used; must be set to zero.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XonLim</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the minimum number of bytes allowed in the input buffer before the XON
character is sent.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XoffLim</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the maximum number of bytes allowed in the input buffer before the XOFF
character is sent. The maximum number of bytes allowed is calculated by
subtracting this value from the size, in bytes, of the input buffer.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Parity</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the parity scheme to be used. This member can be one of the following values:&nbsp;</font></font><!-- Begin third nested table -->
<table BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH="85%" >
<tr VALIGN=TOP>
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Value</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Meaning</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EVENPARITY</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Even</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>MARKPARITY</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Mark</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>NOPARITY</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>No
parity</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>ODDPARITY</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Odd</font></font></td>
</tr>
</table>
</td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>StopBits</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the number of stop bits to be used. This member can be one of the following
values:&nbsp;</font></font><!-- Start of fourth nested table -->
<table BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH="85%" >
<tr VALIGN=TOP>
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Value</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Meaning</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>ONESTOPBIT</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>1
stop bit</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>ONE5STOPBITS</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>1.5
stop bits</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>TWOSTOPBITS</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>2
stop bits</font></font></td>
</tr>
</table>
</td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XonChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the value of the XON character for both transmission and reception.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XoffChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the value of the XOFF character for both transmission and reception.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>ErrorChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the value of the character used to replace bytes received with a parity
error.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EofChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the value of the character used to signal the end of data.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>EvtChar</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Specifies
the value of the character used to cause the EV_RXFLAG event. This setting
does not actually cause anything to happen without the use of EV_RXFLAG
in the <b>SetCommMask</b> function and the use of <b>WaitCommEvent</b>.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>wReserved1</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Reserved;
do not use.&nbsp;</font></font></td>
</tr>
</table>

<h3>
Flow control</h3>
Flow control in serial communications provides a mechanism for suspending
communications while one of the devices is busy or for some reason cannot
do any communication. There are traditionally two types of flow control:
hardware and software.&nbsp;
<p>A common problem with serial communications is write operations that
actually do not write the data to the device. Often, the problem lies in
flow control being utilized when the program did not specify it. A close
examination of the DCB structure reveals that one or more of the following
members may be TRUE: fOutxCtsFlow, fOutxDsrFlow, or fOutX. Another mechanism
to reveal that flow control is enabled is to call <b>ClearCommError</b>
and examine the <b>COMSTAT</b> structure. It will reveal when transmission
is suspended because of flow control.&nbsp;
<p>Before discussing the types of flow control, a good understanding of
some terms is in order. Serial communications takes place between two devices.
Traditionally, there is a PC and a modem or printer. The PC is labeled
the Data Terminal Equipment (DTE). The DTE is sometimes called the <i>host</i>.
The modem, printer, or other peripheral equipment is identified as the
Data Communications Equipment (DCE). The DCE is sometimes referred to as
the <i>device</i>.&nbsp;
<h4>
Hardware flow control</h4>
Hardware flow control uses voltage signals on control lines of the serial
cable to control whether sending or receiving is enabled. The DTE and the
DCE must agree on the types of flow control used for a communications session.
Setting the DCB structure to enable flow control just configures the DTE.
The DCE also needs configuration to make certain the DTE and DCE use the
same type of flow control. There is no mechanism provided by Win32 to set
the flow control of the DCE. DIP switches on the device, or commands sent
to it typically establish its configuration. The following table describes
the control lines, the direction of the flow control, and the line's effect
on the DTE and DCE.&nbsp;
<h3>
<b>Table 3. Hardware Flow-control Lines</b></h3>

<table BORDER CELLSPACING=0 CELLPADDING=5 WIDTH="87%" >
<tr VALIGN=TOP BGCOLOR="#DDDDDD">
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Line
and Direction</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Effect
on DTE/DCE</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>CTS&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>(Clear
To Send)&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Output
flow control</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DCE
sets the line high to indicate that it can receive data. DCE sets the line
low to indicate that it cannot receive data.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fOutxCtsFlow</b> member of the DCB is TRUE, then the DTE will not
send data if this line is low. It will resume sending if the line is high.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fOutxCtsFlow</b> member of the DCB is FALSE, then the state of the
line does not affect transmission.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DSR&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>(Data
Set Ready)&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Output
flow control</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DCE
sets the line high to indicate that it can receive data. DCE sets the line
low to indicate that it cannot receive data.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fOutxDsrFlow</b> member of the DCB is TRUE, then the DTE will not
send data if this line is low. It will resume sending if the line is high.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fOutxDsrFlow</b> member of the DCB is FALSE, then the state of the
line does not affect transmission.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DSR&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>(Data
Set Ready)&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Input
flow control</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the DSR line is low, then data that arrives at the port is ignored. If
the DSR line is high, data that arrives at the port is received.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>This
behavior occurs if the <b>fDsrSensitivity</b> member of the DCB is set
to TRUE. If it is FALSE, then state of the line does not affect reception.</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>RTS&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>(Ready
To Send)&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Input
flow control</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
RTS line is controlled by the DTE.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fRtsControl</b> member of the DCB is set to RTS_CONTROL_HANDSHAKE,
the following flow control is used: If the input buffer has enough room
to receive data (at least half the buffer is empty), the driver sets the
RTS line high. If the input buffer has little room for incoming data (less
than a quarter of the buffer is empty), the driver sets the RTS line low.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fRtsControl</b> member of the DCB is set to RTS_CONTROL_TOGGLE,
the driver sets the RTS line high when data is available for sending. The
driver sets the line low when no data is available for sending. Windows
95 ignores this value and treats it the same as RTS_CONTROL_ENABLE.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fRtsControl</b> member of the DCB is set to RTS_CONTROL_ENABLE or
RTS_CONTROL_DISABLE, the application is free to change the state of the
line as it needs. Note that in this case, the state of the line does not
affect reception.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
DCE will suspend transmission when the line goes low. The DCE will resume
transmission when the line goes high.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DTR&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>(Data
Terminal Ready)&nbsp;</font></font>
<br><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Input
flow control</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
DTR line is controlled by the DTE.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fDtrControl</b> member of the DCB is set to DTR_CONTROL_HANDSHAKE,
the following flow control is used: If the input buffer has enough room
to receive data (at least half the buffer is empty), the driver sets the
DTR line high. If the input buffer has little room for incoming data (less
than a quarter of the buffer is empty), the driver sets the DTR line low.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
the <b>fDtrControl</b> member of the DCB is set to DTR_CONTROL_ENABLE or
DTR_CONTROL_DISABLE, the application is free to change the state of the
line as it needs. In this case, the state of the line does not affect reception.&nbsp;</font></font>
<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>The
DCE will suspend transmission when the line goes low. The DCE will resume
transmission when the line goes high.&nbsp;</font></font></td>
</tr>
</table>

<p>The need for flow control is easy to recognize when the CE_RXOVER error
occurs. This error indicates an overflow of the receive buffer and data
loss. If data arrives at the port faster than it is read, CE_RXOVER can
occur. Increasing the input buffer size may cause the error to occur less
frequently, but does not completely solve the problem. Input flow control
is necessary to completely alleviate this problem. When the driver detects
that the input buffer is nearly full, it will lower the input flow-control
lines. This should cause the DCE to stop transmitting, which gives the
DTE enough time to read the data from the input buffer. When the input
buffer has more room available, the voltage on flow-control lines is set
high, and the DCE resumes sending data.&nbsp;
<p>A similar error is CE_OVERRUN. This error occurs when new data arrives
before the communications hardware and serial communications driver completely
receives old data. This can occur when the transmission speed is too high
for the type of communications hardware or CPU. This can also occur when
the operating system is not free to service the communications hardware.
The only way to alleviate this problem is to apply some combination of
decreasing the transmission speed, replacing the communications hardware,
and increasing the CPU speed. Sometimes third-party hardware drivers that
are not very efficient with CPU resources cause this error. Flow control
cannot completely solve the problems that cause the CE_OVERRUN error, although
it may help to reduce the frequency of the error.&nbsp;
<h4>
Software flow control</h4>
Software flow control utilizes data in the communications stream to control
the transmission and reception of data. Since software flow control uses
two special characters, XOFF and XON, binary transfers cannot use software
flow control; the XON or XOFF characters may appear in the binary data
and would interfere with data transfer. Software flow control befits text-based
communications or data being transferred which does not contain the XON
and XOFF characters.&nbsp;
<p>In order to enable software flow control, the <b>fOutX</b> and <b>fInX</b>
members of the DCB must be set to TRUE. The <b>fOutX</b> member controls
output flow control. The <b>fInX</b> member controls input flow control.&nbsp;
<p>One thing to note is that the DCB allows the program to dynamically
assign the values the system recognizes as flow-control characters. The
<b>XoffChar</b>
member of the DCB dictates the XOFF character for both input and output
flow control. The <b>XonChar</b> member of the DCB similarly dictates the
XON character.&nbsp;
<p>For input flow control, the <b>XoffLim</b> member of the DCB specifies
the minimum amount of free space allowed in the input buffer before the
XOFF character is sent. If the amount of free space in the input buffer
drops below this amount, then XOFF is sent. For input flow control, the
<b>XonLim</b>
member of the DCB specifies the minimum number of bytes allowed in the
input buffer before the XON character is sent. If the amount of data in
the input buffer drops below this value, then XON is sent.&nbsp;
<p>Table 4 lists the behavior of the DTE when using XOFF/XON flow control.&nbsp;
<h3>
<b>Table 4. Software flow-control behavior</b></h3>

<table BORDER CELLSPACING=0 CELLPADDING=5 WIDTH="87%" >
<tr VALIGN=TOP BGCOLOR="#DDDDDD">
<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Flow-control
character</font></font></b></td>

<td><b><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>Behavior</font></font></b></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XOFF
received by DTE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>DTE
transmission is suspended until XON is received. DTE reception continues.
The <b>fOutX</b> member of the DCB controls this behavior.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XON
received by DTE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>If
DTE transmission is suspended because of a previous XOFF character being
received, DTE transmission is resumed. The <b>fOutX</b> member of the DCB
controls this behavior</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XOFF
sent from DTE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XOFF
is automatically sent by the DTE when the receive buffer approaches full.
The actual limit is dictated by the <b>XoffLim</b> member of the DCB. The
<b>fInX</b>
member of the DCB controls this behavior. DTE transmission is controlled
by the <b>fTXContinueOnXoff</b> member of the DCB as described below.&nbsp;</font></font></td>
</tr>

<tr VALIGN=TOP>
<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XON
sent from the DTE</font></font></td>

<td><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-1>XON
is automatically sent by the DTE when the receive buffer approaches empty.
The actual limit is dictated by the <b>XonLim</b> member of the DCB. The
<b>fInX</b>
member of the DCB controls this behavior.&nbsp;</font></font></td>
</tr>
</table>

<p>If software flow control is enabled for input control, then the <b>fTXContinueOnXoff</b>
member of the DCB take effect. The <b>fTXContinueOnXoff</b> member controls
whether transmission is suspended after the XOFF character is automatically
sent by the system. If <b>fTXContinueOnXoff</b> is TRUE, then transmission
continues after the XOFF is sent when the receive buffer is full. If <b>fTXContinueOnXoff</b>
is FALSE, then transmission is suspended until the system automatically
sends the XON character. DCE devices using software flow control will suspend
their sending after the XOFF character is received. Some equipment will
resume sending when the XON character is sent by the DTE. On the other
hand, some DCE devices will resume sending after <i>any</i> character arrives.
The <b>fTXContinueOnXoff</b> member should be set to FALSE when communicating
with a DCE device that resumes sending after any character arrives. If
the DTE continued transmission after it automatically sent the XOFF, the
resumption of transmission would cause the DCE to continue sending, defeating
the XOFF.
<p>There is no mechanism available in the Win32 API to cause the DTE to
behave the same way as these devices. The DCB structure contains no members
for specifying suspended transmission to resume when <i>any</i> character
is received. The XON character is the only character that causes transmission
to resume.
<p>One other interesting note about software flow control is that reception
of XON and XOFF characters causes pending read operations to complete with
zero bytes read. The XON and XOFF characters cannot be read by the application
since they are not placed in the input buffer.
<p>A lot of programs on the market, including the Terminal program that
comes with Windows, give the user three choices for flow control: Hardware,
Software, or None. The Windows operating system itself does not limit an
application in this way. The settings of the DCB allow for Software <i>and</i>
Hardware flow control simultaneously. In fact, it is possible to separately
configure each member of the DCB that affects flow control, which allows
for several different flow-control configurations. The limits placed on
flow-control choices are there for ease-of-use reasons to reduce confusion
for end users. The limits placed on flow-control choices may also be because
devices used for communications may not support all types of flow control.
<h3>
Communications Time-outs</h3>
Another major topic affecting the behavior of read and write operations
is time-outs. Time-outs affect read and write operations in the following
way. If an operation takes longer than the computed time-out period, the
operation is completed. There is no error code that is returned by <b>ReadFile</b>,
<b>WriteFile</b>,
<b>GetOverlappedResult</b>,
or <b>WaitForSingleObject</b>. All indicators used to monitor the operation
indicate that it completed successfully. The only way to tell that the
operation timed out is that the number of bytes actually transferred are
fewer than the number of bytes requested. So, if <b>ReadFile</b> returns
TRUE, but fewer bytes were read than were requested, the operation timed
out. If an overlapped write operation times out, the overlapped event handle
is signaled and <b>WaitForSingleObject</b> returns WAIT_OBJECT_O. <b>GetOverlappedResult</b>
returns TRUE, but dwBytesTransferred contains the number of bytes that
were transferred before the time-out. The following code demonstrates how
to handle this in an overlapped write operation:
<pre><font face="COURIER"><font size=-1>BOOL WriteABuffer(char * lpBuf, DWORD dwToWrite)

{

&nbsp;&nbsp; OVERLAPPED osWrite = {0};

&nbsp;&nbsp; DWORD dwWritten;

&nbsp;&nbsp; DWORD dwRes;

&nbsp;&nbsp; BOOL&nbsp; fRes;



&nbsp;&nbsp; // Create this write operation's OVERLAPPED structure hEvent.

&nbsp;&nbsp; osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

&nbsp;&nbsp; if (osWrite.hEvent == NULL)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error creating overlapped event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;



&nbsp;&nbsp; // Issue write

&nbsp;&nbsp; if (!WriteFile(hComm, lpBuf, dwToWrite, &amp;dwWritten, &amp;osWrite)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetLastError() != ERROR_IO_PENDING) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile failed, but it isn't delayed. Report error.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write is pending.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRes = WaitForSingleObject(osWrite.hEvent, INFINITE);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(dwRes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Overlapped event has been signalled.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WAIT_OBJECT_0:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!GetOverlappedResult(hComm, &amp;osWrite, &amp;dwWritten, FALSE))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dwWritten != dwToWrite) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The write operation timed out. I now need to&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // decide if I want to abort or retry. If I retry,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // I need to send only the bytes that weren't sent.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If I want to abort, I would just set fRes to&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FALSE and return.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write operation completed successfully.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // An error has occurred in <b>WaitForSingleObject</b>. This usually&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // indicates a problem with the overlapped event handle.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp; }

&nbsp;&nbsp; else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // WriteFile completed immediately.



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dwWritten != dwToWrite) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The write operation timed out. I now need to&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // decide if I want to abort or retry. If I retry,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // I need to send only the bytes that weren't sent.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If I want to abort, then I would just set fRes to&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FALSE and return.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = FALSE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRes = TRUE;

&nbsp;&nbsp; }



&nbsp;&nbsp; CloseHandle(osWrite.hEvent);

&nbsp;&nbsp; return fRes;

}</font></font>

</pre>
The <b>SetCommTimeouts</b> function specifies the communications time-outs
for a port. To retrieve the current time-outs for a port, a program calls
the <b>GetCommTimeouts</b> function. An applications should retrieve the
communications time-outs before modifying them. This allows the application
to set time-outs back to their original settings when it finishes with
the port. Following is an example of setting new time-outs using <b>SetCommTimeouts</b>:
<pre><font face="COURIER"><font size=-1>COMMTIMEOUTS timeouts;



timeouts.ReadIntervalTimeout = 20;&nbsp;

timeouts.ReadTotalTimeoutMultiplier = 10;

timeouts.ReadTotalTimeoutConstant = 100;

timeouts.WriteTotalTimeoutMultiplier = 10;

timeouts.WriteTotalTimeoutConstant = 100;



if (!SetCommTimeouts(hComm, &amp;timeouts))

&nbsp;&nbsp; // Error setting timeouts.</font></font>

</pre>

<blockquote><b>Note</b> Once again, communications time-outs are not the
same as time-out values supplied in synchronization functions. <b>WaitForSingleObject</b>,
for instance, uses a time-out value to wait for an object to become signaled;
this is not the same as a communications time-out.</blockquote>
Setting the members of the <b>COMMTIMEOUTS</b> structure to all zeros causes
no time-outs to occur. Nonoverlapped operations will be blocked until all
the requested bytes are transferred. The <b>ReadFile</b> function is blocked
until all the requested characters arrive at the port. The <b>WriteFile</b>
function is blocked until all requested characters are sent out. On the
other hand, an overlapped operation will not finish until all the characters
are transferred or the operation is aborted. The following conditions occur
until the operation is completed:&nbsp;
<ul>
<li>
<b>WaitForSingleObject</b> always returns WAIT_TIMEOUT if a synchronization
time-out is supplied. <b>WaitForSingleObject</b> will be blocked forever
if an INFINITE synchronization time-out is used.&nbsp;</li>

<li>
<b>GetOverlappedResult</b> always returns FALSE and <b>GetLastError</b>
returns ERROR_IO_INCOMPLETE if called directly after the call to <b>GetOverlappedResult</b>.&nbsp;</li>
</ul>
Setting the members of the <b>COMMTIMEOUTS</b> structure in the following
manner causes read operations to complete immediately without waiting for
any new data to arrive:
<pre><font face="COURIER"><font size=-1>COMMTIMEOUTS timeouts;



timeouts.ReadIntervalTimeout = MAXDWORD;&nbsp;

timeouts.ReadTotalTimeoutMultiplier = 0;

timeouts.ReadTotalTimeoutConstant = 0;

timeouts.WriteTotalTimeoutMultiplier = 0;

timeouts.WriteTotalTimeoutConstant = 0;



if (!SetCommTimeouts(hComm, &amp;timeouts))

&nbsp;&nbsp; // Error setting timeouts.</font></font>

</pre>
These settings are necessary when used with an event-based read described
in the "Caveat" section earlier. In order for <b>ReadFile</b> to return
0 bytes read, the <b>ReadIntervalTimeout</b> member of the <b>COMMTIMEOUTS</b>
structure is set to MAXDWORD, and the <b>ReadTimeoutMultiplier</b> and
<b>ReadTimeoutConstant</b>
are both set to zero.&nbsp;
<p>An application must <i>always</i> specifically set communications time-outs
when it uses a communications port. The behavior of read and write operations
is affected by communications time-outs. When a port is initially open,
it uses default time-outs supplied by the driver or time-outs left over
from a previous communications application. If an application assumes that
time-outs are set a certain way, while the time-outs are actually different,
then read and write operations may never complete or may complete too often.&nbsp;
<h2>
<a NAME="conclusion"></a>Conclusion</h2>
This article serves as a discussion of some of the common pitfalls and
questions that arise when developing a serial communications application.
The Multithreaded TTY sample that comes with this article is designed using
many of the techniques discussed here. Download it and try it out. Learning
how it works will provide a thorough understanding of the Win32 serial
communications functions.&nbsp;
<h2>
<a NAME="biblio"></a>Bibliography</h2>
Campbell, Joe. <i>C Programmer's Guide to Serial Communications.</i> 2d
ed. Indianapolis, IN: Howard W. Sams &amp; Company, 1994.&nbsp;
<p>Brain, Marshall. <i>Win32 System Services: The Heart of Windows NT</i>.
Englewood Cliffs, N.J.: Prentice Hall, 1994.&nbsp;
<p>Mirho, Charles and Andy Terrice. "Create Communications Programs for
Windows 95 with the Win32 Comm API." <i>Microsoft Systems Journal 12 </i>(December
1994). (MSDN Library, Books and Periodicals)&nbsp;
<p><a href="#top"><img SRC="uparrow.gif" ALT="up" BORDER=0 height=10 width=14></a>
<hr><!--DocFooterStart-->
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 >
<tr>
<td></td>
</tr>
</table>

<p><font face="Verdana, Arial, Helvetica, Sans-Serif"><font size=-2>&copy;
1997 Microsoft Corporation. All rights reserved. <a href="/Misc/cpyright.htm">Legal
Notices</a></font></font><!--DocFooterEnd--></td>

<td WIDTH="10">&nbsp;</td>
</tr>
</table>

</body>
</html>
